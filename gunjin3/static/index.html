<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gunjin Shogi</title>
    <style>
        body { font-family: sans-serif; text-align: center; }
        #game-container { margin: 20px auto; width: 800px; display: none; }
        #lobby { margin: 20px auto; width: 400px; border: 1px solid #ccc; padding: 20px; }
        #status { margin: 10px; font-weight: bold; }
        .hidden { display: none; }
        
        /* Board Styles */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            gap: 2px;
            background-color: #888;
            padding: 10px;
            margin: 0 auto;
            width: fit-content;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            background-color: #d2b48c;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        
        .cell.hq {
            background-color: #f0f0aa;
            grid-column: span 2; /* HQ spans 2 columns */
            width: 122px; /* 60*2 + 2 gap */
        }
        
        .cell.river-cell {
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: default;
            font-size: 14px;
        }
        .cell.river {
            background-color: #4488ff;
            color: #fff;
            border-top: 2px solid #8b4513;
            border-bottom: 2px solid #8b4513;
        }
        .cell.bridge {
            width: 58px;
            background-color: #d2b48c;
            color: #000;
            border-left: 2px solid #8b4513;
            border-right: 2px solid #8b4513;
        }
        .cell.bridge-col {
            background-color: #e6d8ad;
        }

        .piece {
            width: 90%;
            height: 90%;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }
        
        .piece.FRONT { background-color: #d33; }
        .piece.BACK { background-color: #33d; }
        .piece.UNKNOWN { background-color: #555; color: #aaa; }
        
        .selected { border: 3px solid gold; }
        .last-move { background-color: #ffeb3b55; }

        #controls { margin-top: 20px; }

        /* Setup Phase Styles */
        #setup-container {
            margin-top: 20px;
            padding: 10px;
            border-top: 2px solid #ccc;
        }
        #reserve {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            min-height: 70px;
            background-color: #eee;
            padding: 10px;
            border: 1px dashed #999;
        }
        .reserve-slot {
            width: 60px;
            height: 60px;
            border: 1px solid #ccc;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .piece.draggable {
            cursor: grab;
        }
        .piece.dragging {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <h1>Gunjin Shogi WebUI</h1>
    <div id="status">Connecting...</div>

    <div id="lobby">
        <h2>Lobby</h2>
        <div id="lobby-controls">
            <button id="btn-create">Create Room</button>
            <br><br>
            <input type="text" id="input-room-id" placeholder="Room ID">
            <button id="btn-join">Join Room</button>
        </div>
        <div id="room-info" class="hidden">
            <p>Room ID: <span id="display-room-id"></span></p>
            <p>Role: <span id="display-role"></span></p>
            <p>Status: <span id="room-status">Waiting for opponent...</span></p>
            <button id="btn-ready" disabled>Ready</button>
        </div>
    </div>

    <div id="game-container">
        <h2>Game Board</h2>
        <div id="game-info"></div>
        <div id="board"></div>
        
        <div id="setup-container" class="hidden">
            <h3>Setup Phase</h3>
            <p>Drag pieces from reserve to your territory (Bottom 3 rows).</p>
            <div id="reserve"></div>
            <br>
            <button id="btn-confirm-setup" disabled>Confirm Setup</button>
            <button id="btn-auto-setup">Auto Setup (Random)</button>
        </div>

        <div id="controls">
            <!-- Game controls if any -->
        </div>
    </div>

    <script>
        const statusDiv = document.getElementById('status');
        const lobbyDiv = document.getElementById('lobby');
        const lobbyControls = document.getElementById('lobby-controls');
        const roomInfo = document.getElementById('room-info');
        const gameContainer = document.getElementById('game-container');
        const boardDiv = document.getElementById('board');
        const gameInfoDiv = document.getElementById('game-info');
        
        const btnCreate = document.getElementById('btn-create');
        const btnJoin = document.getElementById('btn-join');
        const btnReady = document.getElementById('btn-ready');
        const btnAutoSetup = document.getElementById('btn-auto-setup');
        const btnConfirmSetup = document.getElementById('btn-confirm-setup');
        const setupContainer = document.getElementById('setup-container');
        const reserveDiv = document.getElementById('reserve');
        
        const inputRoomId = document.getElementById('input-room-id');
        const displayRoomId = document.getElementById('display-room-id');
        const displayRole = document.getElementById('display-role');
        const roomStatus = document.getElementById('room-status');

        const RANK_NAMES = {
            "MARSHAL": "大将",
            "GENERAL": "中将",
            "LT_GEN": "少将",
            "COLONEL": "大佐",
            "LT_COL": "中佐",
            "MAJOR": "少佐",
            "CAPTAIN": "大尉",
            "LIEUTENANT": "中尉",
            "SEC_LT": "少尉",
            "PLANE": "飛行",
            "TANK": "戦車",
            "CAVALRY": "騎兵",
            "ENGINEER": "工兵",
            "SPY": "間諜",
            "MINE": "地雷",
            "FLAG": "軍旗"
        };

        let ws;
        let playerId;
        let mySide;
        let currentTurn;
        let selectedPos = null;
        let boardState = [];
        
        // Setup State
        let isSetupPhase = false;
        let reservePieces = []; // List of rank strings
        let setupBoard = []; // 6x8 array of rank strings or null
        let draggedPiece = null; // { source: 'reserve'|'board', index: int, r: int, c: int, rank: str }

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                statusDiv.textContent = "Connected";
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log("Received:", data);
                handleMessage(data);
            };

            ws.onclose = () => {
                statusDiv.textContent = "Disconnected";
            };
        }

        function handleMessage(data) {
            switch (data.type) {
                case "WELCOME":
                    playerId = data.player_id;
                    break;
                case "ROOM_JOINED":
                    lobbyControls.classList.add('hidden');
                    roomInfo.classList.remove('hidden');
                    displayRoomId.textContent = data.room_id;
                    displayRole.textContent = data.role;
                    break;
                case "PLAYER_JOINED":
                    roomStatus.textContent = `Players: ${data.count}/2`;
                    if (data.count === 2) btnReady.disabled = false;
                    break;
                case "PLAYER_READY":
                    roomStatus.textContent = `Player ${data.player_id} is Ready`;
                    break;
                case "GAME_START":
                    lobbyDiv.classList.add('hidden');
                    gameContainer.style.display = 'block';
                    mySide = data.side;
                    gameInfoDiv.textContent = `You are ${mySide}. Setup Phase.`;
                    
                    startSetupPhase();
                    break;
                case "PLAY_START":
                    isSetupPhase = false;
                    setupContainer.classList.add('hidden');
                    gameInfoDiv.textContent = `Game Started! You are ${mySide}.`;
                    break;
                case "BOARD_UPDATE":
                    boardState = data.board;
                    currentTurn = data.turn;
                    gameInfoDiv.textContent = `Turn: ${currentTurn} (You are ${mySide})`;
                    renderBoard(data.board);
                    break;
                case "COMBAT_RESULT":
                    // data: { my_piece: {rank: ...}, result: "WIN/LOSS/DRAW" }
                    const myRank = RANK_NAMES[data.my_piece.rank] || data.my_piece.rank;
                    alert(`Combat Result: ${data.result} (Your piece: ${myRank})`);
                    break;
                case "GAME_OVER":
                    alert(`Game Over! Winner: ${data.winner}`);
                    break;
                case "ERROR":
                    alert("Error: " + data.msg);
                    break;
            }
        }

        // --- Setup Logic ---

        function startSetupPhase() {
            isSetupPhase = true;
            setupContainer.classList.remove('hidden');
            
            // Initialize Pieces
            const initialPieces = [
                "MARSHAL", "GENERAL", "LT_GEN", "COLONEL", "LT_COL", "MAJOR",
                "CAPTAIN", "CAPTAIN", "LIEUTENANT", "LIEUTENANT", "SEC_LT", "SEC_LT",
                "PLANE", "PLANE", "TANK", "TANK", "CAVALRY", "ENGINEER", "ENGINEER",
                "SPY", "MINE", "MINE", "FLAG"
            ];
            reservePieces = [...initialPieces];
            
            // Initialize Setup Board (6x8)
            setupBoard = Array(6).fill(null).map(() => Array(8).fill(null));
            
            renderSetupUI();
        }

        function renderSetupUI() {
            renderSetupBoard();
            renderReserve();
            checkSetupComplete();
        }

        function renderReserve() {
            reserveDiv.innerHTML = '';
            reservePieces.forEach((rank, index) => {
                const slot = document.createElement('div');
                slot.className = 'reserve-slot';
                
                const pDiv = createPiece({ rank: rank, side: mySide });
                pDiv.classList.add('draggable');
                pDiv.draggable = true;
                pDiv.ondragstart = (e) => handleDragStart(e, { source: 'reserve', index: index, rank: rank });
                
                slot.appendChild(pDiv);
                reserveDiv.appendChild(slot);
            });
            
            // Allow dropping back to reserve
            reserveDiv.ondragover = (e) => e.preventDefault();
            reserveDiv.ondrop = (e) => handleDrop(e, { target: 'reserve' });
        }

        function renderSetupBoard() {
            boardDiv.innerHTML = '';
            const isRotated = (mySide === "BACK");
            const rowIndices = isRotated ? [5, 4, 3, 2, 1, 0] : [0, 1, 2, 3, 4, 5];
            
            // Define valid territory rows (absolute indices)
            // FRONT: 3, 4, 5. BACK: 0, 1, 2.
            const validRows = (mySide === "FRONT") ? [3, 4, 5] : [0, 1, 2];

            rowIndices.forEach((r, visualRowIndex) => {
                // River
                if (visualRowIndex === 3) {
                    const colIndicesRiver = isRotated ? [7, 6, 5, 4, 3, 2, 1, 0] : [0, 1, 2, 3, 4, 5, 6, 7];
                    colIndicesRiver.forEach(c => {
                        const riverCell = document.createElement('div');
                        riverCell.className = 'cell river-cell';
                        if (c === 1 || c === 6) {
                            riverCell.classList.add('bridge');
                            riverCell.textContent = "||";
                        } else {
                            riverCell.classList.add('river');
                            riverCell.textContent = "~";
                        }
                        boardDiv.appendChild(riverCell);
                    });
                }
                
                const colIndices = isRotated ? [7, 6, 5, 4, 3, 2, 1, 0] : [0, 1, 2, 3, 4, 5, 6, 7];
                colIndices.forEach(c => {
                    // HQ Logic (Same as renderBoard but for setup)
                    if ((r === 0 || r === 5) && (c === 3 || c === 4)) {
                        if (isRotated) {
                            if (c === 3) return;
                            const cell = createSetupCell(r, 4, setupBoard[r][3]); // HQ stored at col 3
                            cell.classList.add('hq');
                            cell.textContent = (r === 0) ? "MY HQ" : "ENEMY HQ";
                            if (setupBoard[r][3]) {
                                const pDiv = createPiece({ rank: setupBoard[r][3], side: mySide });
                                makeDraggable(pDiv, r, 3, setupBoard[r][3]);
                                cell.appendChild(pDiv);
                            }
                            boardDiv.appendChild(cell);
                        } else {
                            if (c === 4) return;
                            const cell = createSetupCell(r, 3, setupBoard[r][3]);
                            cell.classList.add('hq');
                            if (setupBoard[r][3]) {
                                const pDiv = createPiece({ rank: setupBoard[r][3], side: mySide });
                                makeDraggable(pDiv, r, 3, setupBoard[r][3]);
                                cell.appendChild(pDiv);
                            }
                            boardDiv.appendChild(cell);
                        }
                    } else {
                        const cell = createSetupCell(r, c, setupBoard[r][c]);
                        if (c === 1 || c === 6) cell.classList.add('bridge-col');
                        
                        if (setupBoard[r][c]) {
                            const pDiv = createPiece({ rank: setupBoard[r][c], side: mySide });
                            makeDraggable(pDiv, r, c, setupBoard[r][c]);
                            cell.appendChild(pDiv);
                        }
                        boardDiv.appendChild(cell);
                    }
                });
            });
        }

        function createSetupCell(r, c, content) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.r = r;
            cell.dataset.c = c;
            
            // Check if valid territory
            const validRows = (mySide === "FRONT") ? [3, 4, 5] : [0, 1, 2];
            if (validRows.includes(r)) {
                cell.style.backgroundColor = "#eef"; // Highlight valid area
                cell.ondragover = (e) => e.preventDefault();
                cell.ondrop = (e) => handleDrop(e, { target: 'board', r: r, c: c });
            } else {
                cell.style.backgroundColor = "#ddd"; // Invalid area
                cell.style.cursor = "not-allowed";
            }
            
            return cell;
        }

        function makeDraggable(el, r, c, rank) {
            el.classList.add('draggable');
            el.draggable = true;
            el.ondragstart = (e) => handleDragStart(e, { source: 'board', r: r, c: c, rank: rank });
        }

        function handleDragStart(e, data) {
            draggedPiece = data;
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('dragging');
        }

        function handleDrop(e, targetData) {
            e.preventDefault();
            if (!draggedPiece) return;
            
            // Logic to move piece
            // 1. Remove from source
            if (draggedPiece.source === 'reserve') {
                reservePieces.splice(draggedPiece.index, 1);
            } else if (draggedPiece.source === 'board') {
                setupBoard[draggedPiece.r][draggedPiece.c] = null;
            }
            
            // 2. Add to target
            if (targetData.target === 'reserve') {
                reservePieces.push(draggedPiece.rank);
            } else if (targetData.target === 'board') {
                // If target occupied, swap? Or return to reserve?
                // Let's swap if source was board, or return to reserve if source was reserve.
                // Simplest: If occupied, move occupant to reserve.
                const existing = setupBoard[targetData.r][targetData.c];
                if (existing) {
                    reservePieces.push(existing);
                }
                setupBoard[targetData.r][targetData.c] = draggedPiece.rank;
            }
            
            draggedPiece = null;
            renderSetupUI();
        }

        function checkSetupComplete() {
            // Enable confirm if reserve is empty
            btnConfirmSetup.disabled = (reservePieces.length > 0);
        }

        btnConfirmSetup.onclick = () => {
            // Build placement list
            const placement = [];
            for (let r = 0; r < 6; r++) {
                for (let c = 0; c < 8; c++) {
                    if (setupBoard[r][c]) {
                        placement.push({ rank: setupBoard[r][c], pos: [r, c] });
                    }
                }
            }
            console.log("Confirming Setup:", placement);
            ws.send(JSON.stringify({ type: "SETUP", placement: placement }));
            btnConfirmSetup.disabled = true;
            gameInfoDiv.textContent = "Setup confirmed. Waiting for opponent...";
        };

        // --- Controls ---

        btnCreate.onclick = () => ws.send(JSON.stringify({ type: "CREATE_ROOM" }));
        btnJoin.onclick = () => ws.send(JSON.stringify({ type: "JOIN_ROOM", room_id: inputRoomId.value }));
        btnReady.onclick = () => {
            ws.send(JSON.stringify({ type: "READY" }));
            btnReady.disabled = true;
            roomStatus.textContent = "Waiting for game start...";
        };

        btnAutoSetup.onclick = () => {
            console.log("Auto Setup clicked");
            // Generate random valid placement
            const pieces = [
                "MARSHAL", "GENERAL", "LT_GEN", "COLONEL", "LT_COL", "MAJOR",
                "CAPTAIN", "CAPTAIN", "LIEUTENANT", "LIEUTENANT", "SEC_LT", "SEC_LT",
                "PLANE", "PLANE", "TANK", "TANK", "CAVALRY", "ENGINEER", "ENGINEER",
                "SPY", "MINE", "MINE", "FLAG"
            ];
            
            // Shuffle
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            
            const placement = [];
            let pIdx = 0;
            
            // Slots: Rows 3,4,5. HQ at (5,3) merged.
            // My side rows are relative to board indices?
            // Server expects absolute indices (0-5).
            // If I am FRONT: Rows 3, 4, 5.
            // If I am BACK: Rows 0, 1, 2.
            
            const rows = mySide === "FRONT" ? [3, 4, 5] : [0, 1, 2];
            
            for (let r of rows) {
                for (let c = 0; c < 8; c++) {
                    // Check HQ
                    if (mySide === "FRONT" && r === 5 && (c === 3 || c === 4)) {
                        if (c === 3) {
                            // HQ Slot
                            if (pIdx < pieces.length) {
                                placement.push({ rank: pieces[pIdx++], pos: [r, c] }); // Use (5,3) for HQ
                            }
                        }
                        // c=4 is skipped (merged)
                    } else if (mySide === "BACK" && r === 0 && (c === 3 || c === 4)) {
                        if (c === 3) {
                            if (pIdx < pieces.length) {
                                placement.push({ rank: pieces[pIdx++], pos: [r, c] });
                            }
                        }
                    } else {
                        if (pIdx < pieces.length) {
                            placement.push({ rank: pieces[pIdx++], pos: [r, c] });
                        }
                    }
                }
            }
            
            console.log("Sending SETUP message with placement:", placement);
            ws.send(JSON.stringify({ type: "SETUP", placement: placement }));
            btnAutoSetup.disabled = true;
        };

        // --- Board Rendering ---

        function renderEmptyBoard() {
            // Just render grid structure
            console.log("Rendering empty board (initial)");
            renderBoard(null);
        }

        function renderBoard(boardData) {
            if (boardData) {
                console.log("Rendering board with data:", boardData);
            }
            boardDiv.innerHTML = '';
            
            // We need to render rows.
            // If mySide is BACK, we should rotate the view?
            // Plan says: "If the player is assigned the 'Top' side (BACK), the board rendering must be rotated 180 degrees so they play from the bottom up."
            
            const isRotated = (mySide === "BACK");
            
            // Rows to iterate: 0 to 5.
            // If rotated: 0 to 5 (but displayed reversed? No, iterate 0..5 but map to visual?)
            // If rotated, visual top is Row 5 (Self), visual bottom is Row 0 (Enemy).
            // Wait, "play from bottom up".
            // Normal (FRONT): Bottom is Row 5 (Self). Top is Row 0 (Enemy).
            // Rotated (BACK): Bottom is Row 0 (Self). Top is Row 5 (Enemy).
            
            // So if Rotated, we iterate rows 5 down to 0?
            // No, CSS Grid fills top-left to bottom-right.
            // Normal: Row 0 -> Row 5.
            // Rotated: Row 5 -> Row 0.
            
            const rowIndices = isRotated ? [5, 4, 3, 2, 1, 0] : [0, 1, 2, 3, 4, 5];
            
            rowIndices.forEach((r, visualRowIndex) => {
                // Check for River Gap
                // River is between Row 2 and 3.
                // In Normal: After Row 2 (visual index 2).
                // In Rotated: After Row 3 (visual index 2).
                // So always after visual row index 2.
                
                if (visualRowIndex === 3) {
                    // Render River Row
                    const colIndicesRiver = isRotated ? [7, 6, 5, 4, 3, 2, 1, 0] : [0, 1, 2, 3, 4, 5, 6, 7];
                    colIndicesRiver.forEach(c => {
                        const riverCell = document.createElement('div');
                        riverCell.className = 'cell river-cell';
                        if (c === 1 || c === 6) {
                            riverCell.classList.add('bridge');
                            riverCell.textContent = "||";
                        } else {
                            riverCell.classList.add('river');
                            riverCell.textContent = "~";
                        }
                        boardDiv.appendChild(riverCell);
                    });
                }
                
                // Columns
                // If rotated, columns should also be reversed? (H->A)
                // Normal: 0->7. Rotated: 7->0.
                const colIndices = isRotated ? [7, 6, 5, 4, 3, 2, 1, 0] : [0, 1, 2, 3, 4, 5, 6, 7];
                
                colIndices.forEach(c => {
                    // Check HQ Merging
                    // HQ is at (0,3)+(0,4) and (5,3)+(5,4).
                    
                    if ((r === 0 || r === 5) && (c === 3 || c === 4)) {
                        // HQ Zone
                        // If rotated (7->0), we hit 4 then 3.
                        // If normal (0->7), we hit 3 then 4.
                        
                        // We want to render the cell ONLY when we hit the "start" of the span in DOM order.
                        // Normal: 3 is start. 4 is skip.
                        // Rotated: 4 is start? No, grid-column span goes right.
                        // If we output a cell at 4 with span 2, it covers 4 and 5 (Visual).
                        // Board Cols: 4 and 3.
                        // Visual Cols: 4 and 5.
                        
                        // If isRotated:
                        // We output cells for 7, 6, 5.
                        // Next is 4. If we output HQ here, it takes Visual 4 and 5.
                        // Visual 4 corresponds to Col 4. Visual 5 corresponds to Col 3.
                        // So we should output at c=4 and skip c=3?
                        
                        if (isRotated) {
                            if (c === 3) return; // Skip 3 (2nd in DOM order)
                            // Render at c=4
                            const cell = createCell(r, 4, boardData ? boardData[r][4] : null);
                            cell.classList.add('hq');
                            // The piece at HQ is logically at (r,3) or (r,4)?
                            // RULES: "HQ is D1-E1... 2 cells merged... Occupancy is 1 slot"
                            // My board implementation might store it at (r,3) or (r,4) or both?
                            // Let's check server logic.
                            // Server place_piece uses (r,c).
                            // Setup uses (5,3) for HQ.
                            // So piece is at (r,3).
                            // So we should check boardData[r][3].
                            
                            if (boardData && boardData[r][3]) {
                                const pDiv = createPiece(boardData[r][3]);
                                cell.appendChild(pDiv);
                            }
                            boardDiv.appendChild(cell);
                        } else {
                            // Normal
                            if (c === 4) return; // Skip 4
                            // Render at c=3
                            const cell = createCell(r, 3, boardData ? boardData[r][3] : null);
                            cell.classList.add('hq');
                            if (boardData && boardData[r][3]) {
                                const pDiv = createPiece(boardData[r][3]);
                                cell.appendChild(pDiv);
                            }
                            boardDiv.appendChild(cell);
                        }
                    } else {
                        // Normal Cell
                        const cell = createCell(r, c, boardData ? boardData[r][c] : null);
                        if (c === 1 || c === 6) {
                            cell.classList.add('bridge-col');
                        }
                        if (boardData && boardData[r][c]) {
                            cell.appendChild(createPiece(boardData[r][c]));
                        }
                        boardDiv.appendChild(cell);
                    }
                });
            });
        }
        
        function createCell(r, c, pieceData) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.r = r;
            cell.dataset.c = c;
            
            cell.onclick = () => handleCellClick(r, c);
            
            if (selectedPos && selectedPos[0] === r && selectedPos[1] === c) {
                cell.classList.add('selected');
            }
            
            return cell;
        }
        
        function createPiece(pData) {
            const p = document.createElement('div');
            p.className = `piece ${pData.side}`;
            if (pData.rank === "UNKNOWN") {
                p.classList.add('UNKNOWN');
                p.textContent = "？";
            } else {
                p.textContent = RANK_NAMES[pData.rank] || pData.rank.substring(0, 2);
            }
            return p;
        }
        
        function handleCellClick(r, c) {
            if (!boardState) return;
            
            // If setup phase, maybe allow swap? (Not implemented yet)
            if (btnAutoSetup.disabled === false) return; // Setup not done
            
            if (selectedPos) {
                // Move attempt
                const [fr, fc] = selectedPos;
                if (fr === r && fc === c) {
                    selectedPos = null; // Deselect
                } else {
                    // Send Move
                    ws.send(JSON.stringify({
                        type: "MOVE",
                        from: [fr, fc],
                        to: [r, c]
                    }));
                    selectedPos = null;
                }
            } else {
                // Select attempt
                const piece = boardState[r][c];
                if (piece && piece.side === mySide) {
                    selectedPos = [r, c];
                }
            }
            renderBoard(boardState); // Re-render to show selection
        }

        connect();
    </script>
</body>
</html>
